---
title: "Complex data pipelines"
teaching: 60
exercises: 7
questions:
- "How can I combine everything I've learned so far?"
- "How can I get my data into a wider format?"
objectives:
- "To be able to combine the different functions we have covered in tandem to create seamless chains of data handling"
- "Creating custom, complex data summaries"
- "Creating complex plots with grids of subplots"
keypoints:
- "Chaining functions together to create larger pipelines"
- "Using facet_grid to greate grids of subplots"
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("08-")
penguins <- palmerpenguins::penguins
library(tidyverse)
```

# Motivation
This session is going to be a little different than the others. 
We will be working with more challenges and exploring different way of combining the things we have learned these days.
So we will spend more time in break-out rooms solving challenges and being "hands-on" while in the 
plenary session we will talk about how we solved the challenges and if things are behaving as we expect or not and why.

Before the break, and a little scattered through the sessions, we have been combining the things we have learned. 
It's when we start using the tidyverse as a whole, all functions together that they start really becoming powerful.
In this last session, we will be working on the things we have learned and applying them together in ways that
uncover some of the cool things we can get done.

Lets say we want to summarise _all_ the measurement variables, i.e. all the columns containing "_". 
We've learned about summaries and grouped summaries. 
Can you think of a way we can do that using the things we've learned?

```{r}
penguins %>% 
  pivot_longer(contains("_"))
```

We've done this before, why is it a clue now? Now that we have learned grouping and summarising, 
what if we now also group by the new name column to get summaries for each column as a row already here!

```{r}
penguins %>% 
  pivot_longer(contains("_")) %>% 
  group_by(name) %>% 
  summarise(mean = mean(value, na.rm = TRUE))
```
Now we are talking! Now we have the mean of each of our observational columns! Lets add other common summary statistics.

```{r}
penguins %>% 
  pivot_longer(contains("_")) %>% 
  group_by(name) %>% 
  summarise(
    mean = mean(value, na.rm = TRUE),
    sd = sd(value, na.rm = TRUE),
    min = min(value, na.rm = TRUE),
    max = max(value, na.rm = TRUE)
  )
```

That's a pretty neat table! The repetition of `na.rm = TRUE` in all is a little tedious, though. Let us use an extra argument in the pivot longer to remove `NA`s in the value column

```{r}
penguins %>% 
  pivot_longer(contains("_")) %>%
  drop_na(value) %>% 
  group_by(name) %>% 
  summarise(
    mean = mean(value, na.rm = TRUE),
    sd = sd(value, na.rm = TRUE),
    min = min(value, na.rm = TRUE),
    max = max(value, na.rm = TRUE)
  )
```

Now we have a pretty decent summary table of our data. 

> ## Challenge 1
> In our code making the summary table. Add another summary column for the number of records, giving it the name `n`.
> _Hint: try the `n()` function._
> > ## Solution
> >
> > ```{r}
> > penguins %>% 
> >   pivot_longer(contains("_")) %>% 
> >   drop_na(value) %>% 
> >   group_by(name) %>% 
> >   summarise(
> >     mean = mean(value),
> >     sd   = sd(value),
> >     min  = min(value),
> >     max  = max(value),
> >     n = n()
> >   )
> > ```
> {: .solution}
{: .challenge}


> ## Challenge 2
> Try grouping by more variables, like species and island, is the output what you would expect it to be?
> > ## Solution
> >
> > ```{r}
> > penguins %>% 
> >   pivot_longer(contains("_")) %>% 
> >   drop_na(value) %>% 
> >   group_by(name, species, island) %>% 
> >   summarise(
> >     mean = mean(value),
> >     sd   = sd(value),
> >     min  = min(value),
> >     max  = max(value),
> >     n = n()
> >   )
> > ```
> {: .solution}
{: .challenge}

> ## Challenge 3
> Create another summary table, with the same descriptive statistics (mean, sd ,min,max and n), 
> but for all numerical variables. Grouped only by the variable names.
> > ## Solution
> >
> > ```{r}
> > penguins %>% 
> >   pivot_longer(where(is.numeric)) %>% 
> >   drop_na(value) %>% 
> >   group_by(name) %>% 
> >   summarise(
> >     mean = mean(value),
> >     sd   = sd(value),
> >     min  = min(value),
> >     max  = max(value),
> >     n = n()
> >   )
> > ```
> {: .solution}
{: .challenge}


## Plotting summaries

Now that we have the summaries, we can use them in plots too! But keep typing or copying the same code over and over is tedious. 
So let us save the summary in its own object, and keep using that.

```{r}
penguins_sum <- penguins %>% 
  pivot_longer(contains("_")) %>% 
  drop_na(value) %>% 
  group_by(name, species, island) %>% 
  summarise(
    mean = mean(value),
    sd   = sd(value),
    min  = min(value),
    max  = max(value),
    n = n()
  ) %>% 
  ungroup()
```

We can for instance make a bar chart with the values from the summary statistics.

```{r, error = TRUE}
penguins_sum %>% 
  ggplot(aes(x = island,
             y = mean,
             fill = species)) +
  geom_bar() +
  facet_wrap(~ name, scales = "free")
```

This error message is telling us that we have used an aesthetic that is not needed in geom_bar. 
That is because geom_bar calculates frequencies by calling `stat_count`. 
But we don't want to count, we already have the values we want to plot.
The ggplot geoms that calculates statistics for plots (like geom bar), have a "stat" option.
When we already have calculated the stat, we can let the geom know to use the values as they are by using `stat = "identity"`.


```{r}
penguins_sum %>% 
  ggplot(aes(x = island, 
             y = mean,
             fill = species)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ name, scales = "free")
```

That is starting to look like something nice. But the way the bars for the species are stacking on top of each other is making it a little hard to read. 
In ggplot, there is an argument called "position", that could help us. 
By default in the bar charts position is set to "stacked". 
We should try the "dodge" option.

```{r}
penguins_sum %>% 
  ggplot(aes(x = island, 
             y = mean,
             fill = species)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_wrap(~ name, scales = "free")
```


> ## Challenge 4
> Create a bar chart based om the penguins summary data, where the standard deviations are on the y axis and species are on the x axis. 
> Make sure to dodge the bar for easier comparisons. 
> Create subplots on the different metrics (_Hint: use facet_wrap()_.
> > ## Solution
> >
> > ```{r}
> > penguins_sum %>% 
> >   ggplot(aes(x = island, 
> >              y = sd,
> >              fill = species)) +
> >   geom_bar(stat = "identity",
> >            position = "dodge") +
> >   facet_wrap(~ name)
> > ```
> {: .solution}
{: .challenge}


> ## Challenge 5
> Change it so that species is both on the x-axis and the fill for the bar chart, and remove the dodge. 
> What argument do you need to add to `facet_wrap()` to make the y-axis scale vary freely between the subplots? 
> Why is this plot misleading?
> > ## Solution
> >
> > ```{r}
> > penguins_sum %>% 
> >   ggplot(aes(x = species, 
> >              y = sd,
> >              fill = species)) +
> >   geom_bar(stat = "identity",
> >            position = "dodge") +
> >   facet_wrap(~ name, scales = "free")
> > ```
> > The last plot is misleading because the data we have summary data by species and island. 
> > Ignoring the island in the plot, means that the values for the different measurements are summed 
> > to create the plot! While it still portrays the data, its ignoring an aspect of the data that 
> > might be significant to take into account. In stead of showing a single standard deviation for, 
> > for instance body mass, would be around 200grams, it looks like now its almost 500grams!
> {: .solution}
{: .challenge}



## Facetting extra long data

But we can get even more creative! 
We mentioned in the pivoting session, that pivoting data is a key skill to really discover how powerful a tool the tidyverse can be.
It's when you start thinking of pivoting as solutions to various tasks that is gets super interesting. 
For instance, in our summary data, we have 4 different statistics, and its hard to get them all nicely into a plot. 
But they all give us some information about the underlying data. 
How can we create a plot that showcases them all?

We can pivot _even longer_ and create subplots for each statistic!

```{r}
penguins_sum %>% 
  pivot_longer(c(mean, sd, min, max)))
```

What is this error? We already have a column named `name` so when we try to let pivot_longer make another one, we get an error.
 Tibbles will not let you create columns with the same name, thankfully! That would be confusing. 
 Let us make sure the new pivoted column with column names has a distinct name.

```{r}
penguins_sum %>% 
  pivot_longer(c(mean, sd, min, max),
               names_to = "stat")
```

Now that we have our extra long data, we can try plotting it all! 
We will switch `facet_wrap()` to `facet_grid()` which creates a grid of subplots. 
The formula for the grid is using both side of the `~` sign. 
And you can think of it like `rows ~ columns`.
So here we are saying we want the `stats` values as rows, and `name` values as columns in the plot grid.

```{r}
penguins_sum %>% 
  pivot_longer(c(mean, sd, min, max),
               names_to = "stat") %>% 
  ggplot(aes(x = species, 
             y = value,
             fill = island)) +
  geom_bar(stat = "identity",
           position = "dodge") +
  facet_grid(stat ~ name)
```

> ## Challenge 6
> It is hard to see the different metrics in the subplots, because they are all on such different scales. 
> Try setting the y-axis to be set freely to allow differences betweem the subplots. 
> Was this the effect you expected?
> > ## Solution
> >
> > ```{r}
> > penguins_sum %>% 
> >   pivot_longer(c(mean, sd, min, max),
> >                names_to = "stat") %>% 
> >   ggplot(aes(x = species, 
> >              y = value,
> >              fill = island)) +
> >   geom_bar(stat = "identity",
> >            position = "dodge") +
> >   facet_grid(stat ~ name, scales = "free")
> > ```
> {: .solution}
{: .challenge}

> ## Challenge 7
> Try switching up what is plotted as rows and columns in the facet. Does this help the plot?
> > ## Solution
> >
> > ```{r}
> > penguins_sum %>% 
> >   pivot_longer(c(mean, sd, min, max),
> >                names_to = "stat") %>% 
> >   ggplot(aes(x = species, 
> >              y = value,
> >              fill = island)) +
> >   geom_bar(stat = "identity",
> >            position = "dodge") +
> >   facet_grid(name ~ stat, scales = "free")
> > ```
> > `facet_grid` is more complex than `facet_wrap` as it will always force the y-axis for rows, and x-axis for columns remain the same.
> > So wile setting scales to free will help a little, it will only do so within each row and column, not each subplot. 
> > When the results do not look as you like, swapping what are rows and columns in the grid can often create better results. 
> {: .solution}
{: .challenge}


